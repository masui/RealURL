// Generated by CoffeeScript 1.12.7
var charkind, charset, crypt, crypt_char, crypturl, utf2bytestr;

charset = ['abcdefghijklmnopqrstuvwxyz', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', '0123456789', '-', '~!@#$%^&*()_=+[{]}|;:.,#?', ' ', "\"'/<>\\`"];

charkind = function(c) {
  var ind, k, ref, results;
  ind = null;
  (function() {
    results = [];
    for (var k = 0, ref = charset.length; 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--){ results.push(k); }
    return results;
  }).apply(this).forEach(function(i) {
    if (charset[i].indexOf(c) >= 0) {
      return ind = i;
    }
  });
  return ind;
};

crypt_char = function(c, n) {
  var chars, cind, ind, kind, len;
  kind = charkind(c);
  chars = charset[kind];
  cind = chars.indexOf(c);
  len = chars.length;
  ind = (n - cind + len) % len;
  return chars[ind];
};

utf2bytestr = function(text) {
  var k, ref, result, results;
  result = "";
  if (text === null) {
    return result;
  }
  (function() {
    results = [];
    for (var k = 0, ref = text.length; 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--){ results.push(k); }
    return results;
  }).apply(this).forEach(function(i) {
    var c;
    c = text.charCodeAt(i);
    if (c <= 0x7f) {
      return result += String.fromCharCode(c);
    } else {
      if (c <= 0x07ff) {
        result += String.fromCharCode(((c >> 6) & 0x1F) | 0xC0);
        return result += String.fromCharCode((c & 0x3F) | 0x80);
      } else {
        result += String.fromCharCode(((c >> 12) & 0x0F) | 0xE0);
        result += String.fromCharCode(((c >> 6) & 0x3F) | 0x80);
        return result += String.fromCharCode((c & 0x3F) | 0x80);
      }
    }
  });
  return result;
};

crypt = function(str, data) {
  var hash, k, ref, res, results;
  hash = data;
  if (!/^[a-fA-F0-9]{32}$/.test(hash)) {
    hash = MD5_hexhash(utf2bytestr(data));
  }
  if (/^[a-f0-9]{32}$/.test(str)) {
    charset = ['abcdef0123456789'];
  }
  if (/^[A-F0-9]{32}$/.test(str)) {
    charset = ['ABCDEF0123456789'];
  }
  res = '';
  (function() {
    results = [];
    for (var k = 0, ref = str.length; 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--){ results.push(k); }
    return results;
  }).apply(this).forEach(function(i) {
    var j, n, s;
    j = i % 8;
    s = hash.substring(j * 4, j * 4 + 4);
    n = parseInt(s, 16);
    return res += crypt_char(str[i], n + i);
  });
  return res;
};

crypturl = function(url, password) {
  var match, match2, newhash, newurl;
  newurl = url;
  if (match = /^(.*\/)[0-9a-f]\/[0-9a-f]\/([0-9a-f]{32})(\.\w+)?$/.exec(url)) {
    newhash = crypt(match[2], password);
    match2 = /^(.)(.)/.exec(newhash);
    newurl = match[1] + match2[1] + '/' + match2[2] + '/' + newhash + match[3];
  } else if (match = /^(.*\/)(\w+)\.([^\/]*)$/.exec(url)) {
    newurl = match[1] + crypt(match[2], password) + '.' + match[3];
  } else if (match = /^(.*\/)(\w+)$/.exec(url)) {
    newurl = match[1] + crypt(match[2], password);
  }
  return newurl;
};
